window.storyFormat({"name":"ChatbookViewer","description":"An interactive chat viewer for Chatbook","author":"Jakob Heuser","image":"icon.svg","url":"github:aibexhq/chatbook","version":"0.2.1","proofing":false,"source":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>\n      {{STORY_NAME}}\n    </title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"author\" content=\"\" />\n    <link rel=\"icon\" href=\"favicon.ico\" />\n\n    <!-- Bootstrap core CSS -->\n    <link\n      rel=\"stylesheet\"\n      href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\"\n      integrity=\"sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB\"\n      crossorigin=\"anonymous\"\n    />\n\n    <style>/* Variables */\n\n:root {\n  --navbar-height: 56px;\n  --user-response-panel-height: 110px;\n  --bg-color: #c7bdb5; /*global chat bg color*/\n  --user-color: #417505; /*user name & placeholder avatar bg*/\n  --speaker-color: #888; /*default color for speaker name & placeholder avatar bg*/\n  --sidebar-bg-color: #fff;\n  --navbar-bg-color: #fff;\n  --passage-bg-color: #fff;\n  --passage-text-color: #000;\n}\n\n/* Atomic Utilities */\n\n.bg-color {\n  background-color: var(--bg-color);\n}\n\n.minh-full {\n  min-height: calc(\n    100vh - var(--navbar-height) - var(--user-response-panel-height) - 17px -\n      5px\n  );\n}\n\n.ml--3 {\n  margin-left: -1rem !important;\n}\n\n@media (min-width: 992px) {\n  .w-lg-auto {\n    width: auto !important;\n  }\n}\n\n/* General */\n\nhtml,\nbody {\n  overflow-x: hidden; /* Prevent scroll on narrow devices */\n  position: relative;\n  min-height: 100%;\n}\n\nbody {\n  padding-top: var(--navbar-height);\n  margin-bottom: calc(\n    var(--user-response-panel-height) + 18px + 5px\n  ); /* + height of hint + hr */\n}\n\n/* Offcanvas sidebar */\n\n@media (max-width: 991.98px) {\n  .offcanvas-collapse {\n    z-index: 1100;\n    position: fixed;\n    top: var(--navbar-height); /* Height of navbar */\n    bottom: 0;\n    left: 100%;\n    width: 100%;\n    padding-right: 1rem;\n    padding-left: 1rem;\n    overflow-y: auto;\n    visibility: hidden;\n    background-color: var(--sidebar-bg-color);\n    transition-timing-function: ease-in-out;\n    transition-duration: 0.3s;\n    transition-property: left, visibility;\n  }\n  .offcanvas-collapse.open {\n    left: 0;\n    visibility: visible;\n  }\n}\n\n/* Nav */\n\nnav.navbar {\n  height: var(--navbar-height);\n  background-color: var(--navbar-bg-color);\n  padding: 0.5rem 15px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\nnav .nav-title {\n  font-size: 1.5rem;\n  line-height: 40px;\n  margin: 0 auto;\n}\n\nnav .nav-icon {\n  width: 35px;\n}\n\n/* Chat Panel */\n\n.chat-panel {\n  padding-top: 15px;\n}\n\n.chat-passage-wrapper {\n  position: relative;\n  margin: 0.5rem 0;\n}\n\n.chat-passage-wrapper[data-speaker=\"you\"] {\n  text-align: right;\n}\n.chat-passage-wrapper[data-speaker=\"you\"] .chat-passage:before {\n  text-align: right;\n  color: var(--user-color);\n}\n\n.chat-passage {\n  display: inline-block;\n  padding: 0.25rem 0.5rem;\n  margin-left: 35px;\n  background-color: var(--passage-bg-color);\n  max-width: calc(100% - 80px);\n  text-align: left;\n}\n@media (min-width: 576px) {\n  .chat-passage {\n    max-width: calc(100% - 100px);\n  }\n}\n@media (min-width: 768px) {\n  .chat-passage {\n    max-width: calc(100% - 80px);\n  }\n}\n@media (min-width: 992px) {\n  .chat-passage {\n    max-width: calc(100% - 100px);\n  }\n}\n\n.chat-passage:before {\n  content: attr(data-speaker);\n  display: block;\n  font-size: 0.75rem;\n  text-transform: capitalize;\n  color: var(--speaker-color);\n}\n\n.chat-passage p {\n  margin: 0;\n}\n\n.chat-passage img {\n  max-width: 100%;\n  max-height: calc(100vh - 2 * var(--user-response-panel-height));\n  padding: 0.25rem 0;\n}\n.chat-passage iframe {\n  max-width: 100%;\n  max-height: calc(100vh - 2 * var(--user-response-panel-height));\n}\n\n.chat-passage figure {\n  margin-bottom: 0.25rem;\n  font-size: 0.75rem;\n}\n\n/* User Response Panel */\n\n.user-response-panel {\n  padding-right: 15px;\n  padding-left: 15px;\n}\n@media (min-width: 992px) {\n  .user-response-panel {\n    max-width: calc(\n      100% / (12 / 6)\n    ); /* 100% / (12/[col width of chat-panel]) */\n    margin: 0 auto;\n  }\n}\n\n.user-response-panel hr {\n  margin: 0;\n  border-top: 5px solid white;\n}\n\n.user-response-hint {\n  font-style: italic;\n  font-size: 0.75rem;\n  text-align: center;\n  height: 18px;\n}\n@media (max-width: 379.98px) {\n  .user-response-hint {\n    font-size: 0.6rem;\n    height: 14px;\n  }\n  body {\n    margin-bottom: calc(\n      var(--user-response-panel-height) + 14px + 5px\n    ); /* + height of hint + hr */\n  }\n  .minh-full {\n    min-height: calc(\n      100vh - var(--navbar-height) - var(--user-response-panel-height) - 14px -\n        5px\n    );\n  }\n}\n@media (max-width: 319.98px) {\n  .user-response-hint {\n    font-size: 0.5rem;\n    height: 12px;\n  }\n  body {\n    margin-bottom: calc(\n      var(--user-response-panel-height) + 12px + 5px\n    ); /* + height of hint + hr */\n  }\n  .minh-full {\n    min-height: calc(\n      100vh - var(--navbar-height) - var(--user-response-panel-height) - 12px -\n        5px\n    );\n  }\n}\n\n.user-reponse-wrapper {\n  height: var(--user-response-panel-height);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.user-response-panel .user-response {\n  display: inline-block;\n  padding: 0.5rem;\n  margin: 0.25rem;\n  background-color: var(--passage-bg-color);\n  color: var(--passage-text-color);\n  border-top: 2px solid transparent;\n  transition: border-color 0.15s ease-in;\n}\n.user-response-panel .user-response:hover {\n  text-decoration: none;\n  border-color: var(--user-color);\n}\n\n/* Passage Avatars */\n\n.chat-passage-wrapper:before {\n  margin-right: 5px;\n  position: absolute;\n  vertical-align: top;\n  content: \"\";\n  width: 30px;\n  height: 30px;\n  background-size: 30px 30px;\n  border-radius: 15px;\n  background-color: var(--speaker-color);\n}\n.chat-passage-wrapper[data-speaker=\"you\"]:before {\n  display: none;\n}\n.chat-passage-wrapper[data-speaker=\"you\"]:after {\n  margin-left: -30px;\n  position: absolute;\n  vertical-align: top;\n  content: \"\";\n  width: 30px;\n  height: 30px;\n  background-size: 30px 30px;\n  border-radius: 15px;\n  background-color: var(--user-color);\n}\n.chat-passage[data-speaker=\"you\"] {\n  margin-left: 0;\n  margin-right: 35px;\n}\n\n/* Typing Animation */\n\ndiv.wave {\n  position: relative;\n  text-align: center;\n  margin-left: auto;\n  margin-right: auto;\n}\ndiv.wave .dot {\n  display: inline-block;\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  margin-right: 2px;\n  background: var(--passage-text-color);\n  animation: wave 1.2s ease-in-out infinite;\n}\ndiv.wave .dot:nth-child(2) {\n  animation-delay: 0.1s;\n}\n\ndiv.wave .dot:nth-child(3) {\n  animation-delay: 0.2s;\n}\n\n@keyframes wave {\n  0%,\n  50%,\n  100% {\n    transform: initial;\n  }\n\n  25% {\n    transform: translateY(-15px);\n  }\n}\n\n/* Directives */\n.directives {\n  display: none;\n  font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\",\n    \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\",\n    \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier,\n    monospace;\n  font-size: 12px;\n}\n\n.directive {\n  white-space: pre;\n  border: 1px dashed #666;\n  position: relative;\n}\n\n.directive::after {\n  content: attr(name);\n  position: absolute;\n  right: 2px;\n  top: 2px;\n  font-weight: bold;\n  font-size: 14px;\n  letter-spacing: 0.2em;\n}\n\nbody.show-directives .directives {\n  display: block;\n}\n\n/* \n * counter extra padding-right added by BS4 modal\n * https://stackoverflow.com/questions/32862394/bootstrap-modals-keep-adding-padding-right-to-body-after-closed\n */\nbody.modal-open {\n  padding-right: 0 !important;\n}\nbody.modal-open .user-response-panel {\n  padding-right: 15px !important;\n}\nbody.modal-open nav.navbar {\n  padding-right: 15px !important;\n}\n</style>\n  </head>\n  <body class=\"bg-white\">\n    <nav class=\"navbar navbar-expand-lg fixed-top\">\n      <h1 id=\"ptitle\" class=\"nav-title\">{{STORY_NAME}}</h1>\n      <label\n        ><input\n          type=\"checkbox\"\n          name=\"show_directives\"\n          id=\"show_directives\"\n        />show directives</label\n      >\n    </nav>\n\n    <main role=\"main\" class=\"container-fluid\">\n      <div class=\"row\">\n        <div class=\"left-sidebar col-lg d-none d-lg-block\">\n          <div\n            id=\"left-sidebar-container\"\n            class=\"content-container position-fixed mt-3 mt-lg-5 m-lg-4\"\n          ></div>\n        </div>\n        <div class=\"chat-panel col-lg-6 minh-full bg-color\">\n          <div id=\"phistory\" class=\"history chat-history\"></div>\n          <div id=\"passage\" class=\"active\"></div>\n          <div id=\"animation-container\">\n            <div class=\"chat-passage-wrapper\">\n              <div class=\"chat-passage\">\n                <div class=\"wave\">\n                  <span class=\"dot\"></span>\n                  <span class=\"dot\"></span>\n                  <span class=\"dot\"></span>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class=\"user-response-panel fixed-bottom bg-color\">\n            <hr />\n            <div\n              id=\"user-response-hint\"\n              class=\"user-response-hint content-container\"\n            ></div>\n            <div id=\"user-response-panel\" class=\"user-reponse-wrapper\"></div>\n          </div>\n        </div>\n        <div class=\"right-sidebar col-lg offcanvas-collapse\">\n          <div class=\"position-fixed ml--3 w-100 w-lg-auto h-100\">\n            <div\n              id=\"right-sidebar-container\"\n              class=\"content-container m-3 m-sm-5 m-lg-3 mt-lg-5 m-xl-5 mt-xl-5\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </main>\n    {{STORY_DATA}} <script>(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) :\n  factory();\n}(function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var classCallCheck = _classCallCheck;\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var defineProperty = _defineProperty;\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    }\n  }\n\n  var arrayWithoutHoles = _arrayWithoutHoles;\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  var iterableToArray = _iterableToArray;\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var nonIterableSpread = _nonIterableSpread;\n\n  function _toConsumableArray(arr) {\n    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n  }\n\n  var toConsumableArray = _toConsumableArray;\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var runtime = (function (exports) {\n\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []);\n\n      // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n      return generator;\n    }\n    exports.wrap = wrap;\n\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n      try {\n        return { type: \"normal\", arg: fn.call(obj, arg) };\n      } catch (err) {\n        return { type: \"throw\", arg: err };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype &&\n        NativeIteratorPrototype !== Op &&\n        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype =\n      Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] =\n      GeneratorFunction.displayName = \"GeneratorFunction\";\n\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function(method) {\n        prototype[method] = function(arg) {\n          return this._invoke(method, arg);\n        };\n      });\n    }\n\n    exports.isGeneratorFunction = function(genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor\n        ? ctor === GeneratorFunction ||\n          // For the native GeneratorFunction constructor, the best we can\n          // do is to check its .name property.\n          (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n        : false;\n    };\n\n    exports.mark = function(genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        if (!(toStringTagSymbol in genFun)) {\n          genFun[toStringTagSymbol] = \"GeneratorFunction\";\n        }\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function(arg) {\n      return { __await: arg };\n    };\n\n    function AsyncIterator(generator) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n          if (value &&\n              typeof value === \"object\" &&\n              hasOwn.call(value, \"__await\")) {\n            return Promise.resolve(value.__await).then(function(value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function(err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return Promise.resolve(value).then(function(unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function(error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new Promise(function(resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise =\n          // If enqueue has been called before, then we want to wait until\n          // all previous Promises have been resolved before calling invoke,\n          // so that results are always delivered in the correct order. If\n          // enqueue has not been called before, then it is important to\n          // call invoke immediately, without waiting on a callback to fire,\n          // so that the async generator function has the opportunity to do\n          // any necessary setup in a predictable way. This predictability\n          // is why the Promise constructor synchronously invokes its\n          // executor callback, and why async functions synchronously\n          // execute code before the first await. Since we implement simple\n          // async functions in terms of async generators, it is especially\n          // important to get this right, even though it requires care.\n          previousPromise ? previousPromise.then(\n            callInvokeWithMethodAndArg,\n            // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg\n          ) : callInvokeWithMethodAndArg();\n      }\n\n      // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n    exports.AsyncIterator = AsyncIterator;\n\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function(innerFn, outerFn, self, tryLocsList) {\n      var iter = new AsyncIterator(\n        wrap(innerFn, outerFn, self, tryLocsList)\n      );\n\n      return exports.isGeneratorFunction(outerFn)\n        ? iter // If outerFn is a generator, return the full iterator.\n        : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n          });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          }\n\n          // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n\n          var record = tryCatch(innerFn, self, context);\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done\n              ? GenStateCompleted\n              : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\n            \"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (! info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value;\n\n        // Resume execution at the desired location (see delegateYield).\n        context.next = delegate.nextLoc;\n\n        // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      }\n\n      // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n\n    Gp[toStringTagSymbol] = \"Generator\";\n\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    Gp[iteratorSymbol] = function() {\n      return this;\n    };\n\n    Gp.toString = function() {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = { tryLoc: locs[0] };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{ tryLoc: \"root\" }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function(object) {\n      var keys = [];\n      for (var key in object) {\n        keys.push(key);\n      }\n      keys.reverse();\n\n      // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        }\n\n        // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1, next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n\n            return next;\n          };\n\n          return next.next = next;\n        }\n      }\n\n      // Return an iterator with no values.\n      return { next: doneResult };\n    }\n    exports.values = values;\n\n    function doneResult() {\n      return { value: undefined$1, done: true };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n\n      reset: function(skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n\n        this.method = \"next\";\n        this.arg = undefined$1;\n\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" &&\n                hasOwn.call(this, name) &&\n                !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n\n      stop: function() {\n        this.done = true;\n\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n\n      dispatchException: function(exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !! caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n\n      abrupt: function(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev &&\n              hasOwn.call(entry, \"finallyLoc\") &&\n              this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry &&\n            (type === \"break\" ||\n             type === \"continue\") &&\n            finallyEntry.tryLoc <= arg &&\n            arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n\n      complete: function(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" ||\n            record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n\n      finish: function(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n\n      \"catch\": function(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n\n        // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n        throw new Error(\"illegal catch attempt\");\n      },\n\n      delegateYield: function(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    };\n\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n\n  }(\n    // If this script is executing as a CommonJS module, use module.exports\n    // as the regeneratorRuntime namespace. Otherwise create a new empty\n    // object. Either way, the resulting object will be used to initialize\n    // the regeneratorRuntime variable at the top of this file.\n     module.exports \n  ));\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n  });\n\n  var regenerator = runtime_1;\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function () {\n      var self = this,\n          args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  var asyncToGenerator = _asyncToGenerator;\n\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0;\n\n  /** `Object#toString` result references. */\n  var symbolTag = '[object Symbol]';\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source);\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /** Built-in value references. */\n  var Symbol$1 = root.Symbol;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike(value) && objectToString.call(value) == symbolTag);\n  }\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  /**\n   * The inverse of `_.escape`; this method converts the HTML entities\n   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to\n   * their corresponding characters.\n   *\n   * **Note:** No other HTML entities are unescaped. To unescape additional\n   * HTML entities use a third-party library like [_he_](https://mths.be/he).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.6.0\n   * @category String\n   * @param {string} [string=''] The string to unescape.\n   * @returns {string} Returns the unescaped string.\n   * @example\n   *\n   * _.unescape('fred, barney, &amp; pebbles');\n   * // => 'fred, barney, & pebbles'\n   */\n  function unescape(string) {\n    string = toString(string);\n    return (string && reHasEscapedHtml.test(string))\n      ? string.replace(reEscapedHtml, unescapeHtmlChar)\n      : string;\n  }\n\n  var lodash_unescape = unescape;\n\n  var TOKEN_ESCAPED_OCTO = \"__TOKEN_ESCAPED_BACKSLASH_OCTO__\";\n  var BLOCK_DIRECTIVE = /^###@([\\S]+)([\\s\\S]*?)###/gm;\n  var INLINE_DIRECTIVE = /^#@([\\S]+)(.*)$/gm;\n\n  var extractDirectives = function extractDirectives(s) {\n    var directives = []; // avoid using escaped items\n\n    s = s.replace(\"\\\\#\", TOKEN_ESCAPED_OCTO);\n\n    while (s.match(BLOCK_DIRECTIVE)) {\n      s = s.replace(BLOCK_DIRECTIVE, function (match, dir, content) {\n        directives.push({\n          name: \"@\".concat(dir),\n          content: content.trim()\n        });\n        return \"\";\n      });\n    }\n\n    while (s.match(INLINE_DIRECTIVE)) {\n      s = s.replace(INLINE_DIRECTIVE, function (match, dir, content) {\n        directives.push({\n          name: \"@\".concat(dir),\n          content: content.trim()\n        });\n        return \"\";\n      });\n    }\n\n    return directives;\n  };\n\n  var LINK_PATTERN = /\\[\\[(.*?)\\]\\]/gm;\n\n  var extractLinks = function extractLinks(str) {\n    var links = [];\n    var original = str;\n\n    while (str.match(LINK_PATTERN)) {\n      str = str.replace(LINK_PATTERN, function (match, t) {\n        var display = t;\n        var target = t; // display|target format\n\n        var barIndex = t.indexOf(\"|\");\n        var rightArrIndex = t.indexOf(\"->\");\n        var leftArrIndex = t.indexOf(\"<-\");\n\n        switch (true) {\n          case barIndex >= 0:\n            display = t.substr(0, barIndex);\n            target = t.substr(barIndex + 1);\n            break;\n\n          case rightArrIndex >= 0:\n            display = t.substr(0, rightArrIndex);\n            target = t.substr(rightArrIndex + 2);\n            break;\n\n          case leftArrIndex >= 0:\n            display = t.substr(leftArrIndex + 2);\n            target = t.substr(0, leftArrIndex);\n            break;\n        }\n\n        links.push({\n          display: display,\n          target: target\n        });\n        return \"\"; // render nothing if it's a twee link\n      });\n    }\n\n    return {\n      links: links,\n      updated: str,\n      original: original\n    };\n  };\n\n  var TOKEN_ESCAPED_OCTO$1 = \"__TOKEN_ESCAPED_BACKSLASH_OCTO__\";\n  var BLOCK_COMMENT = /###[\\s\\S]*?###/gm;\n  var INLINE_COMMENT = /^#.*$/gm;\n\n  var stripComments = function stripComments(str) {\n    return str.replace(\"\\\\#\", TOKEN_ESCAPED_OCTO$1).replace(BLOCK_COMMENT, \"\").replace(INLINE_COMMENT, \"\").replace(TOKEN_ESCAPED_OCTO$1, \"#\").trim();\n  };\n\n  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n  var findStory = function findStory(win) {\n    if (win && win.story) {\n      return win.story;\n    }\n\n    return {\n      state: {}\n    };\n  };\n\n  var renderPassage = function renderPassage(passage) {\n    var source = passage.source;\n    var directives = extractDirectives(source);\n    var result = stripComments(source);\n\n    if (passage) {\n      // remove links if set previously\n      passage.links = [];\n    } // [[links]]\n\n\n    var linkData = extractLinks(result);\n    result = linkData.updated;\n\n    if (passage) {\n      passage.links = linkData.links;\n    } // before handling any tags, handle any/all directives\n\n\n    directives.forEach(function (d) {\n      if (!passage.story.directives[d.name]) return;\n      passage.story.directives[d.name].forEach(function (run) {\n        result = run(d.content, result, passage, passage.story);\n      });\n    }); // if system tag, return an empty render set\n\n    if (passage.hasTag(\"system\")) {\n      return {\n        directives: directives,\n        text: []\n      };\n    } // if prompt tag is set, notify the story\n\n\n    if (passage) {\n      var prompts = passage.prefixTag(\"prompt\");\n\n      if (prompts.length) {\n        passage.story.prompt(prompts[0]);\n      }\n    } // if this is a multiline item, trim, split, and mark each item\n    // return the array\n\n\n    if (passage.hasTag(\"multiline\")) {\n      result = result.trim();\n      return {\n        directives: directives,\n        text: result.split(/[\\r\\n]+/g)\n      };\n    } // else returns an array of 1\n\n\n    return {\n      directives: directives,\n      text: [result]\n    };\n  };\n\n  var Passage = function Passage(id, name, tags, source, story) {\n    var _this = this;\n\n    classCallCheck(this, Passage);\n\n    defineProperty(this, \"id\", null);\n\n    defineProperty(this, \"name\", null);\n\n    defineProperty(this, \"tags\", null);\n\n    defineProperty(this, \"tagDict\", {});\n\n    defineProperty(this, \"source\", null);\n\n    defineProperty(this, \"links\", []);\n\n    defineProperty(this, \"getSpeaker\", function () {\n      var speakerTag = _this.tags.find(function (t) {\n        return t.indexOf(\"speaker-\") === 0;\n      }) || \"\";\n\n      var systemTag = _this.hasTag(\"system\");\n\n      if (speakerTag) return speakerTag.replace(/^speaker-/, \"\");\n      if (systemTag) return \"system\";\n      return null;\n    });\n\n    defineProperty(this, \"prefixTag\", function (pfx, asDict) {\n      return _this.tags.filter(function (t) {\n        return t.indexOf(\"\".concat(pfx, \"-\")) === 0;\n      }).map(function (t) {\n        return t.replace(\"\".concat(pfx, \"-\"), \"\");\n      }).reduce(function (a, t) {\n        if (asDict) return _objectSpread({}, a, defineProperty({}, t, 1));\n        return [].concat(toConsumableArray(a), [t]);\n      }, asDict ? {} : []);\n    });\n\n    defineProperty(this, \"hasTag\", function (t) {\n      return _this.tagDict[t];\n    });\n\n    defineProperty(this, \"render\", function () {\n      return renderPassage(_this);\n    });\n\n    this.id = id;\n    this.name = name;\n    this.tags = tags;\n    this.source = lodash_unescape(source);\n    this.story = story;\n    this.tags.forEach(function (t) {\n      return _this.tagDict[t] = 1;\n    });\n  };\n\n  defineProperty(Passage, \"render\", function (str) {\n    return renderPassage(new Passage(null, null, null, str, findStory(window || null)));\n  });\n\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0;\n\n  /** `Object#toString` result references. */\n  var symbolTag$1 = '[object Symbol]';\n\n  /** Used to match HTML entities and HTML characters. */\n  var reUnescapedHtml = /[&<>\"'`]/g,\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf$1(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf$1(htmlEscapes);\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString$1 = objectProto$1.toString;\n\n  /** Built-in value references. */\n  var Symbol$2 = root$1.Symbol;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,\n      symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString$1(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isSymbol$1(value)) {\n      return symbolToString$1 ? symbolToString$1.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike$1(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol$1(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1);\n  }\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString$1(value) {\n    return value == null ? '' : baseToString$1(value);\n  }\n\n  /**\n   * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\" in `string` to\n   * their corresponding HTML entities.\n   *\n   * **Note:** No other characters are escaped. To escape additional\n   * characters use a third-party library like [_he_](https://mths.be/he).\n   *\n   * Though the \">\" character is escaped for symmetry, characters like\n   * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n   * unless they're part of a tag or unquoted attribute value. See\n   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n   * (under \"semi-related fun fact\") for more details.\n   *\n   * Backticks are escaped because in IE < 9, they can break out of\n   * attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n   * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n   * [#133](https://html5sec.org/#133) of the\n   * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.\n   *\n   * When working with HTML you should always\n   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n   * XSS vectors.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category String\n   * @param {string} [string=''] The string to escape.\n   * @returns {string} Returns the escaped string.\n   * @example\n   *\n   * _.escape('fred, barney, & pebbles');\n   * // => 'fred, barney, &amp; pebbles'\n   */\n  function escape(string) {\n    string = toString$1(string);\n    return (string && reHasUnescapedHtml.test(string))\n      ? string.replace(reUnescapedHtml, escapeHtmlChar)\n      : string;\n  }\n\n  var lodash_escape = escape;\n\n  var selectPassages = \"tw-passagedata\";\n  var selectCss = '*[type=\"text/twine-css\"]';\n  var selectJs = '*[type=\"text/twine-javascript\"]';\n  var selectActiveLink = \"#user-response-panel a[data-passage]\";\n  var selectActiveButton = \"#user-response-panel button[data-passage]\";\n  var selectActiveInput = \"#user-response-panel input\";\n  var selectActive = \".chat-panel .active\";\n  var selectHistory = \".chat-panel .history\";\n  var selectResponses = \"#user-response-panel\";\n  var typingIndicator = \"#animation-container\";\n  var IS_NUMERIC = /^[\\d]+$/;\n  /**\n   * Determine if a provided string contains only numbers\n   * In the case of `pid` values for passages, this is true\n   */\n\n  var isNumeric = function isNumeric(d) {\n    return IS_NUMERIC.test(d);\n  };\n  /**\n   * Format a user passage (such as a response)\n   */\n\n\n  var USER_PASSAGE_TMPL = function USER_PASSAGE_TMPL(_ref) {\n    var id = _ref.id,\n        text = _ref.text;\n    return \"\\n  <div class=\\\"chat-passage-wrapper\\\" data-speaker=\\\"you\\\">\\n    <div class=\\\"chat-passage phistory\\\" data-speaker=\\\"you\\\" data-upassage=\\\"\".concat(id, \"\\\">\\n      \").concat(text, \"\\n    </div>\\n  </div>\\n\");\n  };\n  /**\n   * Format a message from a non-user\n   */\n\n\n  var OTHER_PASSAGE_TMPL = function OTHER_PASSAGE_TMPL(_ref2) {\n    var speaker = _ref2.speaker,\n        tags = _ref2.tags,\n        text = _ref2.text;\n    return \"\\n  <div data-speaker=\\\"\".concat(speaker, \"\\\" class=\\\"chat-passage-wrapper \").concat(tags.join(\" \"), \"\\\">\\n    <div data-speaker=\\\"\").concat(speaker, \"\\\" class=\\\"chat-passage\\\">\\n      \").concat(text, \"\\n    </div>\\n  </div>\\n\");\n  };\n\n  var DIRECTIVES_TMPL = function DIRECTIVES_TMPL(directives) {\n    return \"\\n  <div class=\\\"directives\\\">\\n    \".concat(directives.map(function (_ref3) {\n      var name = _ref3.name,\n          content = _ref3.content;\n      return \"<div class=\\\"directive\\\" name=\\\"\".concat(name, \"\\\">\").concat(content.trim(), \"</div>\");\n    }).join(\"\"), \"\\n  </div>\\n\");\n  };\n  /**\n   * Forces a delay via promises in order to spread out messages\n   */\n\n\n  var delay =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = asyncToGenerator(\n    /*#__PURE__*/\n    regenerator.mark(function _callee() {\n      var t,\n          _args = arguments;\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              t = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                return setTimeout(resolve, t);\n              }));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function delay() {\n      return _ref4.apply(this, arguments);\n    };\n  }(); // Find one/many nodes within a context. We [...findAll] to ensure we're cast as an array\n  // not as a node list\n\n\n  var find = function find(ctx, s) {\n    return ctx.querySelector(s);\n  };\n\n  var findAll = function findAll(ctx, s) {\n    return toConsumableArray(ctx.querySelectorAll(s)) || [];\n  };\n  /**\n   * Standard Twine Format Story Object\n   */\n\n\n  var Story = // Twine v2\n  function Story(win, src) {\n    var _this = this;\n\n    classCallCheck(this, Story);\n\n    defineProperty(this, \"version\", 2);\n\n    defineProperty(this, \"document\", null);\n\n    defineProperty(this, \"story\", null);\n\n    defineProperty(this, \"name\", \"\");\n\n    defineProperty(this, \"startsAt\", 0);\n\n    defineProperty(this, \"current\", 0);\n\n    defineProperty(this, \"history\", []);\n\n    defineProperty(this, \"passages\", {});\n\n    defineProperty(this, \"showPrompt\", false);\n\n    defineProperty(this, \"errorMessage\", \"\\u26A0 %s\");\n\n    defineProperty(this, \"directives\", {});\n\n    defineProperty(this, \"elements\", {});\n\n    defineProperty(this, \"userScripts\", []);\n\n    defineProperty(this, \"userStyles\", []);\n\n    defineProperty(this, \"start\", function () {\n      // activate userscripts and styles\n      _this.userStyles.forEach(function (s) {\n        var t = _this.document.createElement(\"style\");\n\n        t.innerHTML = s;\n\n        _this.document.body.appendChild(t);\n      });\n\n      _this.userScripts.forEach(function (s) {\n        // eval is evil, but this is simply how Twine works\n        // eslint-disable-line\n        globalEval(s);\n      }); // when you click on a[data-passage] (response link)...\n\n\n      _this.document.body.addEventListener(\"click\", function (e) {\n        if (!e.target.matches(selectActiveLink)) {\n          return;\n        }\n\n        _this.advance(_this.findPassage(e.target.getAttribute(\"data-passage\")), e.target.innerHTML);\n      }); // when you click on button[data-passage] (response input)...\n\n\n      _this.document.body.addEventListener(\"click\", function (e) {\n        if (!e.target.matches(selectActiveButton)) {\n          return;\n        } // capture and disable showPrompt feature\n\n\n        var value = find(_this.document, selectActiveInput).value;\n        _this.showPrompt = false;\n\n        _this.advance(_this.findPassage(e.target.getAttribute(\"data-passage\")), value);\n      });\n\n      _this.advance(_this.findPassage(_this.startsAt));\n    });\n\n    defineProperty(this, \"findPassage\", function (idOrName) {\n      if (isNumeric(idOrName)) {\n        return _this.passages[idOrName];\n      } else {\n        // handle passages with ' and \" (can't use a css selector consistently)\n        var p = findAll(_this.story, \"tw-passagedata\").filter(function (p) {\n          return lodash_unescape(p.getAttribute(\"name\")) === idOrName;\n        })[0];\n        if (!p) return null;\n        return _this.passages[p.getAttribute(\"pid\")];\n      }\n    });\n\n    defineProperty(this, \"advance\",\n    /*#__PURE__*/\n    function () {\n      var _ref5 = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee2(passage) {\n        var userText,\n            last,\n            existing,\n            _args2 = arguments;\n        return regenerator.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                userText = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;\n\n                _this.history.push(passage.id);\n\n                last = _this.current; // .active is captured & cleared\n\n                existing = _this.elements.active.innerHTML;\n                _this.elements.active.innerHTML = \"\"; // whatever was in active is moved up into history\n\n                _this.elements.history.innerHTML += existing; // if there is userText, it is added to .history\n\n                if (userText) {\n                  _this.renderUserMessage(last, userText, function (s) {\n                    return _this.elements.history.innerHTML += s;\n                  });\n                } // The new passage is rendered and placed in .active\n                // after all renders, user options are displayed\n\n\n                _context2.next = 9;\n                return _this.renderPassage(passage, function (s) {\n                  return _this.elements.active.innerHTML += s;\n                });\n\n              case 9:\n                if (!(!passage.hasTag(\"wait\") && passage.links.length === 1)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                // auto advance if the wait tag is not set and there is exactly\n                // 1 link found in our pssage.\n                _this.advance(_this.findPassage(passage.links[0].target));\n\n                return _context2.abrupt(\"return\");\n\n              case 12:\n                _this.renderChoices(passage);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n\n    defineProperty(this, \"renderUserMessage\",\n    /*#__PURE__*/\n    function () {\n      var _ref6 = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee3(pid, text, renderer) {\n        return regenerator.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return renderer(USER_PASSAGE_TMPL({\n                  pid: pid,\n                  text: text\n                }));\n\n              case 2:\n                _this.scrollToBottom();\n\n                return _context3.abrupt(\"return\", Promise.resolve());\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x2, _x3, _x4) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n\n    defineProperty(this, \"renderPassage\",\n    /*#__PURE__*/\n    function () {\n      var _ref7 = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee4(passage, renderer) {\n        var speaker, statements, next, content;\n        return regenerator.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                speaker = passage.getSpeaker();\n                statements = passage.render();\n                console.log(statements.directives);\n                _context4.next = 5;\n                return renderer(DIRECTIVES_TMPL(statements.directives));\n\n              case 5:\n                next = statements.text.shift();\n\n                _this.showTyping();\n\n              case 7:\n                if (!next) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                content = OTHER_PASSAGE_TMPL({\n                  speaker: speaker,\n                  tags: passage.tags,\n                  text: next\n                });\n                _context4.next = 11;\n                return delay(_this.calculateDelay(next));\n\n              case 11:\n                _context4.next = 13;\n                return renderer(content);\n\n              case 13:\n                next = statements.text.shift();\n                _context4.next = 7;\n                break;\n\n              case 16:\n                _this.hideTyping();\n\n                _this.scrollToBottom();\n\n                return _context4.abrupt(\"return\", Promise.resolve());\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x5, _x6) {\n        return _ref7.apply(this, arguments);\n      };\n    }());\n\n    defineProperty(this, \"calculateDelay\", function (txt) {\n      var typingDelayRatio = 0.3;\n      var rate = 20; // ms\n\n      return txt.length * rate * typingDelayRatio;\n    });\n\n    defineProperty(this, \"showTyping\", function () {\n      find(_this.document, typingIndicator).style.visibility = \"visible\";\n    });\n\n    defineProperty(this, \"hideTyping\", function () {\n      find(_this.document, typingIndicator).style.visibility = \"hidden\";\n    });\n\n    defineProperty(this, \"scrollToBottom\", function () {\n      var hist = find(_this.document, \"#phistory\");\n      document.scrollingElement.scrollTop = hist.offsetHeight;\n    });\n\n    defineProperty(this, \"removeChoices\", function () {\n      var panel = find(_this.document, selectResponses);\n      panel.innerHTML = \"\";\n    });\n\n    defineProperty(this, \"renderChoices\", function (passage) {\n      _this.removeChoices();\n\n      var panel = find(_this.document, selectResponses);\n      passage.links.forEach(function (l) {\n        panel.innerHTML += \"<a href=\\\"javascript:void(0)\\\" class=\\\"user-response\\\" data-passage=\\\"\".concat(lodash_escape(l.target), \"\\\">\").concat(l.display, \"</a>\");\n      });\n    });\n\n    defineProperty(this, \"directive\", function (id, cb) {\n      if (!_this.directives[id]) {\n        _this.directives[id] = [];\n      }\n\n      _this.directives[id].push(cb);\n    });\n\n    this.window = win;\n\n    if (src) {\n      this.document = document.implementation.createHTMLDocument(\"Chatbook Injected Content\");\n    } else {\n      this.document = document;\n    }\n\n    this.story = find(this.document, \"tw-storydata\"); // elements\n\n    this.elements = {\n      active: find(this.document, selectActive),\n      history: find(this.document, selectHistory)\n    }; // properties of story node\n\n    this.name = this.story.getAttribute(\"name\") || \"\";\n    this.startsAt = this.story.getAttribute(\"startnode\") || 0;\n    findAll(this.story, selectPassages).forEach(function (p) {\n      var id = parseInt(p.getAttribute(\"pid\"));\n      var name = p.getAttribute(\"name\");\n      var tags = (p.getAttribute(\"tags\") || \"\").split(/\\s+/g);\n      var passage = p.innerHTML || \"\";\n      _this.passages[id] = new Passage(id, name, tags, passage, _this);\n    });\n    find(this.document, \"title\").innerHTML = this.name;\n    find(this.document, \"#ptitle\").innerHTML = this.name;\n    this.userScripts = (findAll(this.document, selectJs) || []).map(function (el) {\n      return el.innerHTML;\n    });\n    this.userStyles = (findAll(this.document, selectCss) || []).map(function (el) {\n      return el.innerHTML;\n    });\n  }\n  /**\n   * Starts the story by setting up listeners and then advancing\n   * to the first item in the stack\n   */\n  ;\n\n  (function (win) {\n    if (typeof win !== \"undefined\") {\n      win.document.addEventListener(\"DOMContentLoaded\", function (event) {\n        win.globalEval = eval;\n        win.story = new Story(win);\n\n        if (win.document.querySelector(\"#show_directives\").checked) {\n          win.document.body.classList.add(\"show-directives\");\n        }\n\n        win.story.start();\n      });\n      win.document.querySelector(\"#show_directives\").addEventListener(\"change\", function (e) {\n        if (e.target.checked) {\n          win.document.body.classList.add(\"show-directives\");\n        } else {\n          win.document.body.classList.remove(\"show-directives\");\n        }\n      });\n    }\n  })(window || undefined);\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhdGJvb2sudW1kLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLnVuZXNjYXBlL2luZGV4LmpzIiwiLi4vc3JjL2NvbW1vbi9leHRyYWN0RGlyZWN0aXZlcy5qcyIsIi4uL3NyYy9jb21tb24vZXh0cmFjdExpbmtzLmpzIiwiLi4vc3JjL2NvbW1vbi9zdHJpcENvbW1lbnRzLmpzIiwiLi4vc3JjL3R3aW5lL1Bhc3NhZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLmVzY2FwZS9pbmRleC5qcyIsIi4uL3NyYy90d2luZS9TdG9yeS5qcyIsIi4uL3NyYy90d2luZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzl8Izk2KTsvZyxcbiAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbnZhciBodG1sVW5lc2NhcGVzID0ge1xuICAnJmFtcDsnOiAnJicsXG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmIzM5Oyc6IFwiJ1wiLFxuICAnJiM5NjsnOiAnYCdcbn07XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBgJiMzOTtgLCBhbmQgYCYjOTY7YCBpbiBgc3RyaW5nYCB0b1xuICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC42LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5lc2NhcGU7XG4iLCJjb25zdCBUT0tFTl9FU0NBUEVEX09DVE8gPSBcIl9fVE9LRU5fRVNDQVBFRF9CQUNLU0xBU0hfT0NUT19fXCI7XG5jb25zdCBCTE9DS19ESVJFQ1RJVkUgPSAvXiMjI0AoW1xcU10rKShbXFxzXFxTXSo/KSMjIy9nbTtcbmNvbnN0IElOTElORV9ESVJFQ1RJVkUgPSAvXiNAKFtcXFNdKykoLiopJC9nbTtcblxuY29uc3QgZXh0cmFjdERpcmVjdGl2ZXMgPSBzID0+IHtcbiAgY29uc3QgZGlyZWN0aXZlcyA9IFtdO1xuXG4gIC8vIGF2b2lkIHVzaW5nIGVzY2FwZWQgaXRlbXNcbiAgcyA9IHMucmVwbGFjZShcIlxcXFwjXCIsIFRPS0VOX0VTQ0FQRURfT0NUTyk7XG5cbiAgd2hpbGUgKHMubWF0Y2goQkxPQ0tfRElSRUNUSVZFKSkge1xuICAgIHMgPSBzLnJlcGxhY2UoQkxPQ0tfRElSRUNUSVZFLCAobWF0Y2gsIGRpciwgY29udGVudCkgPT4ge1xuICAgICAgZGlyZWN0aXZlcy5wdXNoKHsgbmFtZTogYEAke2Rpcn1gLCBjb250ZW50OiBjb250ZW50LnRyaW0oKSB9KTtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0pO1xuICB9XG5cbiAgd2hpbGUgKHMubWF0Y2goSU5MSU5FX0RJUkVDVElWRSkpIHtcbiAgICBzID0gcy5yZXBsYWNlKElOTElORV9ESVJFQ1RJVkUsIChtYXRjaCwgZGlyLCBjb250ZW50KSA9PiB7XG4gICAgICBkaXJlY3RpdmVzLnB1c2goeyBuYW1lOiBgQCR7ZGlyfWAsIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpIH0pO1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dHJhY3REaXJlY3RpdmVzO1xuIiwiY29uc3QgTElOS19QQVRURVJOID0gL1xcW1xcWyguKj8pXFxdXFxdL2dtO1xuXG5jb25zdCBleHRyYWN0TGlua3MgPSBzdHIgPT4ge1xuICBjb25zdCBsaW5rcyA9IFtdO1xuICBjb25zdCBvcmlnaW5hbCA9IHN0cjtcblxuICB3aGlsZSAoc3RyLm1hdGNoKExJTktfUEFUVEVSTikpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShMSU5LX1BBVFRFUk4sIChtYXRjaCwgdCkgPT4ge1xuICAgICAgbGV0IGRpc3BsYXkgPSB0O1xuICAgICAgbGV0IHRhcmdldCA9IHQ7XG5cbiAgICAgIC8vIGRpc3BsYXl8dGFyZ2V0IGZvcm1hdFxuICAgICAgY29uc3QgYmFySW5kZXggPSB0LmluZGV4T2YoXCJ8XCIpO1xuICAgICAgY29uc3QgcmlnaHRBcnJJbmRleCA9IHQuaW5kZXhPZihcIi0+XCIpO1xuICAgICAgY29uc3QgbGVmdEFyckluZGV4ID0gdC5pbmRleE9mKFwiPC1cIik7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIGJhckluZGV4ID49IDA6XG4gICAgICAgICAgZGlzcGxheSA9IHQuc3Vic3RyKDAsIGJhckluZGV4KTtcbiAgICAgICAgICB0YXJnZXQgPSB0LnN1YnN0cihiYXJJbmRleCArIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJpZ2h0QXJySW5kZXggPj0gMDpcbiAgICAgICAgICBkaXNwbGF5ID0gdC5zdWJzdHIoMCwgcmlnaHRBcnJJbmRleCk7XG4gICAgICAgICAgdGFyZ2V0ID0gdC5zdWJzdHIocmlnaHRBcnJJbmRleCArIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGxlZnRBcnJJbmRleCA+PSAwOlxuICAgICAgICAgIGRpc3BsYXkgPSB0LnN1YnN0cihsZWZ0QXJySW5kZXggKyAyKTtcbiAgICAgICAgICB0YXJnZXQgPSB0LnN1YnN0cigwLCBsZWZ0QXJySW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgZGlzcGxheSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBcIlwiOyAvLyByZW5kZXIgbm90aGluZyBpZiBpdCdzIGEgdHdlZSBsaW5rXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmtzLFxuICAgIHVwZGF0ZWQ6IHN0cixcbiAgICBvcmlnaW5hbCxcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dHJhY3RMaW5rcztcbiIsImNvbnN0IFRPS0VOX0VTQ0FQRURfT0NUTyA9IFwiX19UT0tFTl9FU0NBUEVEX0JBQ0tTTEFTSF9PQ1RPX19cIjtcblxuY29uc3QgQkxPQ0tfQ09NTUVOVCA9IC8jIyNbXFxzXFxTXSo/IyMjL2dtO1xuY29uc3QgSU5MSU5FX0NPTU1FTlQgPSAvXiMuKiQvZ207XG5cbmNvbnN0IHN0cmlwQ29tbWVudHMgPSBzdHIgPT5cbiAgc3RyXG4gICAgLnJlcGxhY2UoXCJcXFxcI1wiLCBUT0tFTl9FU0NBUEVEX09DVE8pXG4gICAgLnJlcGxhY2UoQkxPQ0tfQ09NTUVOVCwgXCJcIilcbiAgICAucmVwbGFjZShJTkxJTkVfQ09NTUVOVCwgXCJcIilcbiAgICAucmVwbGFjZShUT0tFTl9FU0NBUEVEX09DVE8sIFwiI1wiKVxuICAgIC50cmltKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmlwQ29tbWVudHM7XG4iLCJpbXBvcnQgdW5lc2NhcGUgZnJvbSBcImxvZGFzaC51bmVzY2FwZVwiO1xuaW1wb3J0IGV4dHJhY3REaXJlY3RpdmVzIGZyb20gXCIuLi9jb21tb24vZXh0cmFjdERpcmVjdGl2ZXNcIjtcbmltcG9ydCBleHRyYWN0TGlua3MgZnJvbSBcIi4uL2NvbW1vbi9leHRyYWN0TGlua3NcIjtcbmltcG9ydCBzdHJpcENvbW1lbnRzIGZyb20gXCIuLi9jb21tb24vc3RyaXBDb21tZW50c1wiO1xuXG5jb25zdCBmaW5kU3RvcnkgPSB3aW4gPT4ge1xuICBpZiAod2luICYmIHdpbi5zdG9yeSkge1xuICAgIHJldHVybiB3aW4uc3Rvcnk7XG4gIH1cbiAgcmV0dXJuIHsgc3RhdGU6IHt9IH07XG59O1xuXG5jb25zdCByZW5kZXJQYXNzYWdlID0gcGFzc2FnZSA9PiB7XG4gIGNvbnN0IHNvdXJjZSA9IHBhc3NhZ2Uuc291cmNlO1xuXG4gIGNvbnN0IGRpcmVjdGl2ZXMgPSBleHRyYWN0RGlyZWN0aXZlcyhzb3VyY2UpO1xuICBsZXQgcmVzdWx0ID0gc3RyaXBDb21tZW50cyhzb3VyY2UpO1xuXG4gIGlmIChwYXNzYWdlKSB7XG4gICAgLy8gcmVtb3ZlIGxpbmtzIGlmIHNldCBwcmV2aW91c2x5XG4gICAgcGFzc2FnZS5saW5rcyA9IFtdO1xuICB9XG5cbiAgLy8gW1tsaW5rc11dXG4gIGNvbnN0IGxpbmtEYXRhID0gZXh0cmFjdExpbmtzKHJlc3VsdCk7XG4gIHJlc3VsdCA9IGxpbmtEYXRhLnVwZGF0ZWQ7XG4gIGlmIChwYXNzYWdlKSB7XG4gICAgcGFzc2FnZS5saW5rcyA9IGxpbmtEYXRhLmxpbmtzO1xuICB9XG5cbiAgLy8gYmVmb3JlIGhhbmRsaW5nIGFueSB0YWdzLCBoYW5kbGUgYW55L2FsbCBkaXJlY3RpdmVzXG4gIGRpcmVjdGl2ZXMuZm9yRWFjaChkID0+IHtcbiAgICBpZiAoIXBhc3NhZ2Uuc3RvcnkuZGlyZWN0aXZlc1tkLm5hbWVdKSByZXR1cm47XG4gICAgcGFzc2FnZS5zdG9yeS5kaXJlY3RpdmVzW2QubmFtZV0uZm9yRWFjaChydW4gPT4ge1xuICAgICAgcmVzdWx0ID0gcnVuKGQuY29udGVudCwgcmVzdWx0LCBwYXNzYWdlLCBwYXNzYWdlLnN0b3J5KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaWYgc3lzdGVtIHRhZywgcmV0dXJuIGFuIGVtcHR5IHJlbmRlciBzZXRcbiAgaWYgKHBhc3NhZ2UuaGFzVGFnKFwic3lzdGVtXCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICB0ZXh0OiBbXSxcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgcHJvbXB0IHRhZyBpcyBzZXQsIG5vdGlmeSB0aGUgc3RvcnlcbiAgaWYgKHBhc3NhZ2UpIHtcbiAgICBjb25zdCBwcm9tcHRzID0gcGFzc2FnZS5wcmVmaXhUYWcoXCJwcm9tcHRcIik7XG4gICAgaWYgKHByb21wdHMubGVuZ3RoKSB7XG4gICAgICBwYXNzYWdlLnN0b3J5LnByb21wdChwcm9tcHRzWzBdKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgbXVsdGlsaW5lIGl0ZW0sIHRyaW0sIHNwbGl0LCBhbmQgbWFyayBlYWNoIGl0ZW1cbiAgLy8gcmV0dXJuIHRoZSBhcnJheVxuICBpZiAocGFzc2FnZS5oYXNUYWcoXCJtdWx0aWxpbmVcIikpIHtcbiAgICByZXN1bHQgPSByZXN1bHQudHJpbSgpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgdGV4dDogcmVzdWx0LnNwbGl0KC9bXFxyXFxuXSsvZyksXG4gICAgfTtcbiAgfVxuXG4gIC8vIGVsc2UgcmV0dXJucyBhbiBhcnJheSBvZiAxXG4gIHJldHVybiB7XG4gICAgZGlyZWN0aXZlcyxcbiAgICB0ZXh0OiBbcmVzdWx0XSxcbiAgfTtcbn07XG5cbmNsYXNzIFBhc3NhZ2Uge1xuICBpZCA9IG51bGw7XG4gIG5hbWUgPSBudWxsO1xuICB0YWdzID0gbnVsbDtcbiAgdGFnRGljdCA9IHt9O1xuICBzb3VyY2UgPSBudWxsO1xuICBsaW5rcyA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGlkLCBuYW1lLCB0YWdzLCBzb3VyY2UsIHN0b3J5KSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50YWdzID0gdGFncztcbiAgICB0aGlzLnNvdXJjZSA9IHVuZXNjYXBlKHNvdXJjZSk7XG4gICAgdGhpcy5zdG9yeSA9IHN0b3J5O1xuXG4gICAgdGhpcy50YWdzLmZvckVhY2godCA9PiAodGhpcy50YWdEaWN0W3RdID0gMSkpO1xuICB9XG5cbiAgZ2V0U3BlYWtlciA9ICgpID0+IHtcbiAgICBjb25zdCBzcGVha2VyVGFnID0gdGhpcy50YWdzLmZpbmQodCA9PiB0LmluZGV4T2YoXCJzcGVha2VyLVwiKSA9PT0gMCkgfHwgXCJcIjtcbiAgICBjb25zdCBzeXN0ZW1UYWcgPSB0aGlzLmhhc1RhZyhcInN5c3RlbVwiKTtcbiAgICBpZiAoc3BlYWtlclRhZykgcmV0dXJuIHNwZWFrZXJUYWcucmVwbGFjZSgvXnNwZWFrZXItLywgXCJcIik7XG4gICAgaWYgKHN5c3RlbVRhZykgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcHJlZml4VGFnID0gKHBmeCwgYXNEaWN0KSA9PlxuICAgIHRoaXMudGFnc1xuICAgICAgLmZpbHRlcih0ID0+IHQuaW5kZXhPZihgJHtwZnh9LWApID09PSAwKVxuICAgICAgLm1hcCh0ID0+IHQucmVwbGFjZShgJHtwZnh9LWAsIFwiXCIpKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKGEsIHQpID0+IHtcbiAgICAgICAgICBpZiAoYXNEaWN0KVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYSxcbiAgICAgICAgICAgICAgW3RdOiAxLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBbLi4uYSwgdF07XG4gICAgICAgIH0sXG4gICAgICAgIGFzRGljdCA/IHt9IDogW11cbiAgICAgICk7XG5cbiAgaGFzVGFnID0gdCA9PiB0aGlzLnRhZ0RpY3RbdF07XG5cbiAgLy8gc3RhdGljIGFuZCBpbnN0YW5jZSByZW5kZXJzXG4gIHN0YXRpYyByZW5kZXIgPSBzdHIgPT5cbiAgICByZW5kZXJQYXNzYWdlKFxuICAgICAgbmV3IFBhc3NhZ2UobnVsbCwgbnVsbCwgbnVsbCwgc3RyLCBmaW5kU3Rvcnkod2luZG93IHx8IG51bGwpKVxuICAgICk7XG4gIHJlbmRlciA9ICgpID0+IHJlbmRlclBhc3NhZ2UodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NhZ2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJ2AnOiAnJiM5NjsnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIgaW4gYHN0cmluZ2AgdG9cbiAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBCYWNrdGlja3MgYXJlIGVzY2FwZWQgYmVjYXVzZSBpbiBJRSA8IDksIHRoZXkgY2FuIGJyZWFrIG91dCBvZlxuICogYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAqIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZiB0aGVcbiAqIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlO1xuIiwiaW1wb3J0IFBhc3NhZ2UgZnJvbSBcIi4vUGFzc2FnZVwiO1xuaW1wb3J0IGVzY2FwZSBmcm9tIFwibG9kYXNoLmVzY2FwZVwiO1xuaW1wb3J0IHVuZXNjYXBlIGZyb20gXCJsb2Rhc2gudW5lc2NhcGVcIjtcblxuY29uc3Qgc2VsZWN0UGFzc2FnZXMgPSBcInR3LXBhc3NhZ2VkYXRhXCI7XG5jb25zdCBzZWxlY3RDc3MgPSAnKlt0eXBlPVwidGV4dC90d2luZS1jc3NcIl0nO1xuY29uc3Qgc2VsZWN0SnMgPSAnKlt0eXBlPVwidGV4dC90d2luZS1qYXZhc2NyaXB0XCJdJztcbmNvbnN0IHNlbGVjdEFjdGl2ZUxpbmsgPSBcIiN1c2VyLXJlc3BvbnNlLXBhbmVsIGFbZGF0YS1wYXNzYWdlXVwiO1xuY29uc3Qgc2VsZWN0QWN0aXZlQnV0dG9uID0gXCIjdXNlci1yZXNwb25zZS1wYW5lbCBidXR0b25bZGF0YS1wYXNzYWdlXVwiO1xuY29uc3Qgc2VsZWN0QWN0aXZlSW5wdXQgPSBcIiN1c2VyLXJlc3BvbnNlLXBhbmVsIGlucHV0XCI7XG5jb25zdCBzZWxlY3RBY3RpdmUgPSBcIi5jaGF0LXBhbmVsIC5hY3RpdmVcIjtcbmNvbnN0IHNlbGVjdEhpc3RvcnkgPSBcIi5jaGF0LXBhbmVsIC5oaXN0b3J5XCI7XG5jb25zdCBzZWxlY3RSZXNwb25zZXMgPSBcIiN1c2VyLXJlc3BvbnNlLXBhbmVsXCI7XG5jb25zdCB0eXBpbmdJbmRpY2F0b3IgPSBcIiNhbmltYXRpb24tY29udGFpbmVyXCI7XG5cbmNvbnN0IElTX05VTUVSSUMgPSAvXltcXGRdKyQvO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHByb3ZpZGVkIHN0cmluZyBjb250YWlucyBvbmx5IG51bWJlcnNcbiAqIEluIHRoZSBjYXNlIG9mIGBwaWRgIHZhbHVlcyBmb3IgcGFzc2FnZXMsIHRoaXMgaXMgdHJ1ZVxuICovXG5jb25zdCBpc051bWVyaWMgPSBkID0+IElTX05VTUVSSUMudGVzdChkKTtcblxuLyoqXG4gKiBGb3JtYXQgYSB1c2VyIHBhc3NhZ2UgKHN1Y2ggYXMgYSByZXNwb25zZSlcbiAqL1xuY29uc3QgVVNFUl9QQVNTQUdFX1RNUEwgPSAoeyBpZCwgdGV4dCB9KSA9PiBgXG4gIDxkaXYgY2xhc3M9XCJjaGF0LXBhc3NhZ2Utd3JhcHBlclwiIGRhdGEtc3BlYWtlcj1cInlvdVwiPlxuICAgIDxkaXYgY2xhc3M9XCJjaGF0LXBhc3NhZ2UgcGhpc3RvcnlcIiBkYXRhLXNwZWFrZXI9XCJ5b3VcIiBkYXRhLXVwYXNzYWdlPVwiJHtpZH1cIj5cbiAgICAgICR7dGV4dH1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gO1xuXG4vKipcbiAqIEZvcm1hdCBhIG1lc3NhZ2UgZnJvbSBhIG5vbi11c2VyXG4gKi9cbmNvbnN0IE9USEVSX1BBU1NBR0VfVE1QTCA9ICh7IHNwZWFrZXIsIHRhZ3MsIHRleHQgfSkgPT4gYFxuICA8ZGl2IGRhdGEtc3BlYWtlcj1cIiR7c3BlYWtlcn1cIiBjbGFzcz1cImNoYXQtcGFzc2FnZS13cmFwcGVyICR7dGFncy5qb2luKFwiIFwiKX1cIj5cbiAgICA8ZGl2IGRhdGEtc3BlYWtlcj1cIiR7c3BlYWtlcn1cIiBjbGFzcz1cImNoYXQtcGFzc2FnZVwiPlxuICAgICAgJHt0ZXh0fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbmA7XG5cbmNvbnN0IERJUkVDVElWRVNfVE1QTCA9IGRpcmVjdGl2ZXMgPT4gYFxuICA8ZGl2IGNsYXNzPVwiZGlyZWN0aXZlc1wiPlxuICAgICR7ZGlyZWN0aXZlc1xuICAgICAgLm1hcChcbiAgICAgICAgKHsgbmFtZSwgY29udGVudCB9KSA9PlxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwiZGlyZWN0aXZlXCIgbmFtZT1cIiR7bmFtZX1cIj4ke2NvbnRlbnQudHJpbSgpfTwvZGl2PmBcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXCIpfVxuICA8L2Rpdj5cbmA7XG5cbi8qKlxuICogRm9yY2VzIGEgZGVsYXkgdmlhIHByb21pc2VzIGluIG9yZGVyIHRvIHNwcmVhZCBvdXQgbWVzc2FnZXNcbiAqL1xuY29uc3QgZGVsYXkgPSBhc3luYyAodCA9IDApID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0KSk7XG5cbi8vIEZpbmQgb25lL21hbnkgbm9kZXMgd2l0aGluIGEgY29udGV4dC4gV2UgWy4uLmZpbmRBbGxdIHRvIGVuc3VyZSB3ZSdyZSBjYXN0IGFzIGFuIGFycmF5XG4vLyBub3QgYXMgYSBub2RlIGxpc3RcbmNvbnN0IGZpbmQgPSAoY3R4LCBzKSA9PiBjdHgucXVlcnlTZWxlY3RvcihzKTtcbmNvbnN0IGZpbmRBbGwgPSAoY3R4LCBzKSA9PiBbLi4uY3R4LnF1ZXJ5U2VsZWN0b3JBbGwocyldIHx8IFtdO1xuXG4vKipcbiAqIFN0YW5kYXJkIFR3aW5lIEZvcm1hdCBTdG9yeSBPYmplY3RcbiAqL1xuY2xhc3MgU3Rvcnkge1xuICB2ZXJzaW9uID0gMjsgLy8gVHdpbmUgdjJcblxuICBkb2N1bWVudCA9IG51bGw7XG4gIHN0b3J5ID0gbnVsbDtcbiAgbmFtZSA9IFwiXCI7XG4gIHN0YXJ0c0F0ID0gMDtcbiAgY3VycmVudCA9IDA7XG4gIGhpc3RvcnkgPSBbXTtcbiAgcGFzc2FnZXMgPSB7fTtcbiAgc2hvd1Byb21wdCA9IGZhbHNlO1xuICBlcnJvck1lc3NhZ2UgPSBcIlxcdTI2YTAgJXNcIjtcblxuICBkaXJlY3RpdmVzID0ge307XG4gIGVsZW1lbnRzID0ge307XG5cbiAgdXNlclNjcmlwdHMgPSBbXTtcbiAgdXNlclN0eWxlcyA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHdpbiwgc3JjKSB7XG4gICAgdGhpcy53aW5kb3cgPSB3aW47XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFxuICAgICAgICBcIkNoYXRib29rIEluamVjdGVkIENvbnRlbnRcIlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIHRoaXMuc3RvcnkgPSBmaW5kKHRoaXMuZG9jdW1lbnQsIFwidHctc3RvcnlkYXRhXCIpO1xuXG4gICAgLy8gZWxlbWVudHNcbiAgICB0aGlzLmVsZW1lbnRzID0ge1xuICAgICAgYWN0aXZlOiBmaW5kKHRoaXMuZG9jdW1lbnQsIHNlbGVjdEFjdGl2ZSksXG4gICAgICBoaXN0b3J5OiBmaW5kKHRoaXMuZG9jdW1lbnQsIHNlbGVjdEhpc3RvcnkpLFxuICAgIH07XG5cbiAgICAvLyBwcm9wZXJ0aWVzIG9mIHN0b3J5IG5vZGVcbiAgICB0aGlzLm5hbWUgPSB0aGlzLnN0b3J5LmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgXCJcIjtcbiAgICB0aGlzLnN0YXJ0c0F0ID0gdGhpcy5zdG9yeS5nZXRBdHRyaWJ1dGUoXCJzdGFydG5vZGVcIikgfHwgMDtcblxuICAgIGZpbmRBbGwodGhpcy5zdG9yeSwgc2VsZWN0UGFzc2FnZXMpLmZvckVhY2gocCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KHAuZ2V0QXR0cmlidXRlKFwicGlkXCIpKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBwLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICBjb25zdCB0YWdzID0gKHAuZ2V0QXR0cmlidXRlKFwidGFnc1wiKSB8fCBcIlwiKS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgIGNvbnN0IHBhc3NhZ2UgPSBwLmlubmVySFRNTCB8fCBcIlwiO1xuXG4gICAgICB0aGlzLnBhc3NhZ2VzW2lkXSA9IG5ldyBQYXNzYWdlKGlkLCBuYW1lLCB0YWdzLCBwYXNzYWdlLCB0aGlzKTtcbiAgICB9KTtcblxuICAgIGZpbmQodGhpcy5kb2N1bWVudCwgXCJ0aXRsZVwiKS5pbm5lckhUTUwgPSB0aGlzLm5hbWU7XG4gICAgZmluZCh0aGlzLmRvY3VtZW50LCBcIiNwdGl0bGVcIikuaW5uZXJIVE1MID0gdGhpcy5uYW1lO1xuXG4gICAgdGhpcy51c2VyU2NyaXB0cyA9IChmaW5kQWxsKHRoaXMuZG9jdW1lbnQsIHNlbGVjdEpzKSB8fCBbXSkubWFwKFxuICAgICAgZWwgPT4gZWwuaW5uZXJIVE1MXG4gICAgKTtcbiAgICB0aGlzLnVzZXJTdHlsZXMgPSAoZmluZEFsbCh0aGlzLmRvY3VtZW50LCBzZWxlY3RDc3MpIHx8IFtdKS5tYXAoXG4gICAgICBlbCA9PiBlbC5pbm5lckhUTUxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgc3RvcnkgYnkgc2V0dGluZyB1cCBsaXN0ZW5lcnMgYW5kIHRoZW4gYWR2YW5jaW5nXG4gICAqIHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzdGFja1xuICAgKi9cbiAgc3RhcnQgPSAoKSA9PiB7XG4gICAgLy8gYWN0aXZhdGUgdXNlcnNjcmlwdHMgYW5kIHN0eWxlc1xuICAgIHRoaXMudXNlclN0eWxlcy5mb3JFYWNoKHMgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdC5pbm5lckhUTUwgPSBzO1xuICAgICAgdGhpcy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO1xuICAgIH0pO1xuICAgIHRoaXMudXNlclNjcmlwdHMuZm9yRWFjaChzID0+IHtcbiAgICAgIC8vIGV2YWwgaXMgZXZpbCwgYnV0IHRoaXMgaXMgc2ltcGx5IGhvdyBUd2luZSB3b3Jrc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgZ2xvYmFsRXZhbChzKTtcbiAgICB9KTtcblxuICAgIC8vIHdoZW4geW91IGNsaWNrIG9uIGFbZGF0YS1wYXNzYWdlXSAocmVzcG9uc2UgbGluaykuLi5cbiAgICB0aGlzLmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRhcmdldC5tYXRjaGVzKHNlbGVjdEFjdGl2ZUxpbmspKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZHZhbmNlKFxuICAgICAgICB0aGlzLmZpbmRQYXNzYWdlKGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcGFzc2FnZVwiKSksXG4gICAgICAgIGUudGFyZ2V0LmlubmVySFRNTFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHdoZW4geW91IGNsaWNrIG9uIGJ1dHRvbltkYXRhLXBhc3NhZ2VdIChyZXNwb25zZSBpbnB1dCkuLi5cbiAgICB0aGlzLmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRhcmdldC5tYXRjaGVzKHNlbGVjdEFjdGl2ZUJ1dHRvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjYXB0dXJlIGFuZCBkaXNhYmxlIHNob3dQcm9tcHQgZmVhdHVyZVxuICAgICAgY29uc3QgdmFsdWUgPSBmaW5kKHRoaXMuZG9jdW1lbnQsIHNlbGVjdEFjdGl2ZUlucHV0KS52YWx1ZTtcbiAgICAgIHRoaXMuc2hvd1Byb21wdCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmFkdmFuY2UoXG4gICAgICAgIHRoaXMuZmluZFBhc3NhZ2UoZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYXNzYWdlXCIpKSxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkdmFuY2UodGhpcy5maW5kUGFzc2FnZSh0aGlzLnN0YXJ0c0F0KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBwYXNzYWdlIGJhc2VkIG9uIGl0cyBpZCBvciBuYW1lXG4gICAqL1xuICBmaW5kUGFzc2FnZSA9IGlkT3JOYW1lID0+IHtcbiAgICBpZiAoaXNOdW1lcmljKGlkT3JOYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFzc2FnZXNbaWRPck5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgcGFzc2FnZXMgd2l0aCAnIGFuZCBcIiAoY2FuJ3QgdXNlIGEgY3NzIHNlbGVjdG9yIGNvbnNpc3RlbnRseSlcbiAgICAgIGNvbnN0IHAgPSBmaW5kQWxsKHRoaXMuc3RvcnksIFwidHctcGFzc2FnZWRhdGFcIikuZmlsdGVyKFxuICAgICAgICBwID0+IHVuZXNjYXBlKHAuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSkgPT09IGlkT3JOYW1lXG4gICAgICApWzBdO1xuICAgICAgaWYgKCFwKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLnBhc3NhZ2VzW3AuZ2V0QXR0cmlidXRlKFwicGlkXCIpXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIHN0b3J5IHRvIHRoZSBwYXNzYWdlIHNwZWNpZmllZCwgb3B0aW9uYWxseSBhZGRpbmcgdXNlclRleHRcbiAgICovXG4gIGFkdmFuY2UgPSBhc3luYyAocGFzc2FnZSwgdXNlclRleHQgPSBudWxsKSA9PiB7XG4gICAgdGhpcy5oaXN0b3J5LnB1c2gocGFzc2FnZS5pZCk7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuY3VycmVudDtcblxuICAgIC8vIC5hY3RpdmUgaXMgY2FwdHVyZWQgJiBjbGVhcmVkXG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmVsZW1lbnRzLmFjdGl2ZS5pbm5lckhUTUw7XG4gICAgdGhpcy5lbGVtZW50cy5hY3RpdmUuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIC8vIHdoYXRldmVyIHdhcyBpbiBhY3RpdmUgaXMgbW92ZWQgdXAgaW50byBoaXN0b3J5XG4gICAgdGhpcy5lbGVtZW50cy5oaXN0b3J5LmlubmVySFRNTCArPSBleGlzdGluZztcblxuICAgIC8vIGlmIHRoZXJlIGlzIHVzZXJUZXh0LCBpdCBpcyBhZGRlZCB0byAuaGlzdG9yeVxuICAgIGlmICh1c2VyVGV4dCkge1xuICAgICAgdGhpcy5yZW5kZXJVc2VyTWVzc2FnZShcbiAgICAgICAgbGFzdCxcbiAgICAgICAgdXNlclRleHQsXG4gICAgICAgIHMgPT4gKHRoaXMuZWxlbWVudHMuaGlzdG9yeS5pbm5lckhUTUwgKz0gcylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhlIG5ldyBwYXNzYWdlIGlzIHJlbmRlcmVkIGFuZCBwbGFjZWQgaW4gLmFjdGl2ZVxuICAgIC8vIGFmdGVyIGFsbCByZW5kZXJzLCB1c2VyIG9wdGlvbnMgYXJlIGRpc3BsYXllZFxuICAgIGF3YWl0IHRoaXMucmVuZGVyUGFzc2FnZShcbiAgICAgIHBhc3NhZ2UsXG4gICAgICBzID0+ICh0aGlzLmVsZW1lbnRzLmFjdGl2ZS5pbm5lckhUTUwgKz0gcylcbiAgICApO1xuXG4gICAgaWYgKCFwYXNzYWdlLmhhc1RhZyhcIndhaXRcIikgJiYgcGFzc2FnZS5saW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGF1dG8gYWR2YW5jZSBpZiB0aGUgd2FpdCB0YWcgaXMgbm90IHNldCBhbmQgdGhlcmUgaXMgZXhhY3RseVxuICAgICAgLy8gMSBsaW5rIGZvdW5kIGluIG91ciBwc3NhZ2UuXG4gICAgICB0aGlzLmFkdmFuY2UodGhpcy5maW5kUGFzc2FnZShwYXNzYWdlLmxpbmtzWzBdLnRhcmdldCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyQ2hvaWNlcyhwYXNzYWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRleHQgYXMgaWYgaXQgY2FtZSBmcm9tIHRoZSB1c2VyXG4gICAqL1xuICByZW5kZXJVc2VyTWVzc2FnZSA9IGFzeW5jIChwaWQsIHRleHQsIHJlbmRlcmVyKSA9PiB7XG4gICAgYXdhaXQgcmVuZGVyZXIoXG4gICAgICBVU0VSX1BBU1NBR0VfVE1QTCh7XG4gICAgICAgIHBpZCxcbiAgICAgICAgdGV4dCxcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBUd2luZStDaGF0Ym9vayBwYXNzYWdlIG9iamVjdFxuICAgKi9cbiAgcmVuZGVyUGFzc2FnZSA9IGFzeW5jIChwYXNzYWdlLCByZW5kZXJlcikgPT4ge1xuICAgIGNvbnN0IHNwZWFrZXIgPSBwYXNzYWdlLmdldFNwZWFrZXIoKTtcbiAgICBsZXQgc3RhdGVtZW50cyA9IHBhc3NhZ2UucmVuZGVyKCk7XG4gICAgY29uc29sZS5sb2coc3RhdGVtZW50cy5kaXJlY3RpdmVzKTtcblxuICAgIGF3YWl0IHJlbmRlcmVyKERJUkVDVElWRVNfVE1QTChzdGF0ZW1lbnRzLmRpcmVjdGl2ZXMpKTtcblxuICAgIGxldCBuZXh0ID0gc3RhdGVtZW50cy50ZXh0LnNoaWZ0KCk7XG4gICAgdGhpcy5zaG93VHlwaW5nKCk7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBPVEhFUl9QQVNTQUdFX1RNUEwoe1xuICAgICAgICBzcGVha2VyLFxuICAgICAgICB0YWdzOiBwYXNzYWdlLnRhZ3MsXG4gICAgICAgIHRleHQ6IG5leHQsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlbGF5KHRoaXMuY2FsY3VsYXRlRGVsYXkobmV4dCkpOyAvLyB0b2RvXG4gICAgICBhd2FpdCByZW5kZXJlcihjb250ZW50KTtcbiAgICAgIG5leHQgPSBzdGF0ZW1lbnRzLnRleHQuc2hpZnQoKTtcbiAgICB9XG4gICAgdGhpcy5oaWRlVHlwaW5nKCk7XG4gICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHJvdWdoIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBhIHdhaXRpbmcgcGVyaW9kIGJhc2VkIG9uIHN0cmluZyBsZW5ndGhcbiAgICovXG4gIGNhbGN1bGF0ZURlbGF5ID0gdHh0ID0+IHtcbiAgICBjb25zdCB0eXBpbmdEZWxheVJhdGlvID0gMC4zO1xuICAgIGNvbnN0IHJhdGUgPSAyMDsgLy8gbXNcbiAgICByZXR1cm4gdHh0Lmxlbmd0aCAqIHJhdGUgKiB0eXBpbmdEZWxheVJhdGlvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgdHlwaW5nIGluZGljYXRvclxuICAgKi9cbiAgc2hvd1R5cGluZyA9ICgpID0+IHtcbiAgICBmaW5kKHRoaXMuZG9jdW1lbnQsIHR5cGluZ0luZGljYXRvcikuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgdHlwaW5nIGluZGljYXRvclxuICAgKi9cbiAgaGlkZVR5cGluZyA9ICgpID0+IHtcbiAgICBmaW5kKHRoaXMuZG9jdW1lbnQsIHR5cGluZ0luZGljYXRvcikuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIGRvY3VtZW50IGFzIGZhciBhcyBwb3NzaWJsZSAoYmFzZWQgb24gaGlzdG9yeSBjb250YWluZXIncyBoZWlnaHQpXG4gICAqL1xuICBzY3JvbGxUb0JvdHRvbSA9ICgpID0+IHtcbiAgICBjb25zdCBoaXN0ID0gZmluZCh0aGlzLmRvY3VtZW50LCBcIiNwaGlzdG9yeVwiKTtcbiAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9IGhpc3Qub2Zmc2V0SGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNob2ljZXMgcGFuZWxcbiAgICovXG4gIHJlbW92ZUNob2ljZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgcGFuZWwgPSBmaW5kKHRoaXMuZG9jdW1lbnQsIHNlbGVjdFJlc3BvbnNlcyk7XG4gICAgcGFuZWwuaW5uZXJIVE1MID0gXCJcIjtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2hvaWNlcyBwYW5lbCB3aXRoIGEgc2V0IG9mIG9wdGlvbnMgYmFzZWQgb24gcGFzc2FnZSBsaW5rc1xuICAgKi9cbiAgcmVuZGVyQ2hvaWNlcyA9IHBhc3NhZ2UgPT4ge1xuICAgIHRoaXMucmVtb3ZlQ2hvaWNlcygpO1xuICAgIGNvbnN0IHBhbmVsID0gZmluZCh0aGlzLmRvY3VtZW50LCBzZWxlY3RSZXNwb25zZXMpO1xuICAgIHBhc3NhZ2UubGlua3MuZm9yRWFjaChsID0+IHtcbiAgICAgIHBhbmVsLmlubmVySFRNTCArPSBgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwidXNlci1yZXNwb25zZVwiIGRhdGEtcGFzc2FnZT1cIiR7ZXNjYXBlKFxuICAgICAgICBsLnRhcmdldFxuICAgICAgKX1cIj4ke2wuZGlzcGxheX08L2E+YDtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY3VzdG9tIGRpcmVjdGl2ZSBmb3IgdGhpcyBzdG9yeVxuICAgKiBTaWduYXR1cmUgb2YgKGRpcmVjdGl2ZUNvbnRlbnQsIG91dHB1dFRleHQsIHN0b3J5LCBwYXNzYWdlLCBuZXh0KVxuICAgKi9cbiAgZGlyZWN0aXZlID0gKGlkLCBjYikgPT4ge1xuICAgIGlmICghdGhpcy5kaXJlY3RpdmVzW2lkXSkge1xuICAgICAgdGhpcy5kaXJlY3RpdmVzW2lkXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmRpcmVjdGl2ZXNbaWRdLnB1c2goY2IpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yeTtcbiIsImltcG9ydCBTdG9yeSBmcm9tIFwiLi9TdG9yeVwiO1xuXG4od2luID0+IHtcbiAgaWYgKHR5cGVvZiB3aW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHdpbi5nbG9iYWxFdmFsID0gZXZhbDtcbiAgICAgIHdpbi5zdG9yeSA9IG5ldyBTdG9yeSh3aW4pO1xuICAgICAgaWYgKHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Nob3dfZGlyZWN0aXZlc1wiKS5jaGVja2VkKSB7XG4gICAgICAgIHdpbi5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJzaG93LWRpcmVjdGl2ZXNcIik7XG4gICAgICB9XG4gICAgICB3aW4uc3Rvcnkuc3RhcnQoKTtcbiAgICB9KTtcblxuICAgIHdpbi5kb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoXCIjc2hvd19kaXJlY3RpdmVzXCIpXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBlID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICB3aW4uZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwic2hvdy1kaXJlY3RpdmVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbi5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93LWRpcmVjdGl2ZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59KSh3aW5kb3cgfHwgdW5kZWZpbmVkKTtcbiJdLCJuYW1lcyI6WyJ1bmRlZmluZWQiLCJyZXF1aXJlJCQwIiwiZ2xvYmFsIiwiU3ltYm9sIiwiVE9LRU5fRVNDQVBFRF9PQ1RPIiwiQkxPQ0tfRElSRUNUSVZFIiwiSU5MSU5FX0RJUkVDVElWRSIsImV4dHJhY3REaXJlY3RpdmVzIiwicyIsImRpcmVjdGl2ZXMiLCJyZXBsYWNlIiwibWF0Y2giLCJkaXIiLCJjb250ZW50IiwicHVzaCIsIm5hbWUiLCJ0cmltIiwiTElOS19QQVRURVJOIiwiZXh0cmFjdExpbmtzIiwic3RyIiwibGlua3MiLCJvcmlnaW5hbCIsInQiLCJkaXNwbGF5IiwidGFyZ2V0IiwiYmFySW5kZXgiLCJpbmRleE9mIiwicmlnaHRBcnJJbmRleCIsImxlZnRBcnJJbmRleCIsInN1YnN0ciIsInVwZGF0ZWQiLCJCTE9DS19DT01NRU5UIiwiSU5MSU5FX0NPTU1FTlQiLCJzdHJpcENvbW1lbnRzIiwiZmluZFN0b3J5Iiwid2luIiwic3RvcnkiLCJzdGF0ZSIsInJlbmRlclBhc3NhZ2UiLCJwYXNzYWdlIiwic291cmNlIiwicmVzdWx0IiwibGlua0RhdGEiLCJmb3JFYWNoIiwiZCIsInJ1biIsImhhc1RhZyIsInRleHQiLCJwcm9tcHRzIiwicHJlZml4VGFnIiwibGVuZ3RoIiwicHJvbXB0Iiwic3BsaXQiLCJQYXNzYWdlIiwiaWQiLCJ0YWdzIiwic3BlYWtlclRhZyIsImZpbmQiLCJzeXN0ZW1UYWciLCJwZngiLCJhc0RpY3QiLCJmaWx0ZXIiLCJtYXAiLCJyZWR1Y2UiLCJhIiwidGFnRGljdCIsInVuZXNjYXBlIiwid2luZG93IiwiSU5GSU5JVFkiLCJzeW1ib2xUYWciLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJyb290IiwiYmFzZVByb3BlcnR5T2YiLCJvYmplY3RQcm90byIsIm9iamVjdFRvU3RyaW5nIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsImlzU3ltYm9sIiwiaXNPYmplY3RMaWtlIiwidG9TdHJpbmciLCJzZWxlY3RQYXNzYWdlcyIsInNlbGVjdENzcyIsInNlbGVjdEpzIiwic2VsZWN0QWN0aXZlTGluayIsInNlbGVjdEFjdGl2ZUJ1dHRvbiIsInNlbGVjdEFjdGl2ZUlucHV0Iiwic2VsZWN0QWN0aXZlIiwic2VsZWN0SGlzdG9yeSIsInNlbGVjdFJlc3BvbnNlcyIsInR5cGluZ0luZGljYXRvciIsIklTX05VTUVSSUMiLCJpc051bWVyaWMiLCJ0ZXN0IiwiVVNFUl9QQVNTQUdFX1RNUEwiLCJPVEhFUl9QQVNTQUdFX1RNUEwiLCJzcGVha2VyIiwiam9pbiIsIkRJUkVDVElWRVNfVE1QTCIsImRlbGF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY3R4IiwicXVlcnlTZWxlY3RvciIsImZpbmRBbGwiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiU3RvcnkiLCJzcmMiLCJ1c2VyU3R5bGVzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiYm9keSIsImFwcGVuZENoaWxkIiwidXNlclNjcmlwdHMiLCJnbG9iYWxFdmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJtYXRjaGVzIiwiYWR2YW5jZSIsImZpbmRQYXNzYWdlIiwiZ2V0QXR0cmlidXRlIiwidmFsdWUiLCJzaG93UHJvbXB0Iiwic3RhcnRzQXQiLCJpZE9yTmFtZSIsInBhc3NhZ2VzIiwicCIsInVzZXJUZXh0IiwiaGlzdG9yeSIsImxhc3QiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJlbGVtZW50cyIsImFjdGl2ZSIsInJlbmRlclVzZXJNZXNzYWdlIiwicmVuZGVyQ2hvaWNlcyIsInBpZCIsInJlbmRlcmVyIiwic2Nyb2xsVG9Cb3R0b20iLCJnZXRTcGVha2VyIiwic3RhdGVtZW50cyIsInJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXh0Iiwic2hpZnQiLCJzaG93VHlwaW5nIiwiY2FsY3VsYXRlRGVsYXkiLCJoaWRlVHlwaW5nIiwidHh0IiwidHlwaW5nRGVsYXlSYXRpbyIsInJhdGUiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJoaXN0Iiwic2Nyb2xsaW5nRWxlbWVudCIsInNjcm9sbFRvcCIsIm9mZnNldEhlaWdodCIsInBhbmVsIiwicmVtb3ZlQ2hvaWNlcyIsImwiLCJlc2NhcGUiLCJjYiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwicGFyc2VJbnQiLCJlbCIsImV2ZW50IiwiZXZhbCIsImNoZWNrZWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzdGFydCIsInJlbW92ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxTQUFTLGVBQWUs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\n</script>\n  </body>\n</html>\n"})